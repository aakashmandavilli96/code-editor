Index: code-editor-src/extensions/sagemaker-extension/src/extension.ts
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/src/extension.ts
@@ -0,0 +1,205 @@
+import * as vscode from 'vscode';
+import * as fs from 'fs';
+import { SessionWarning } from "./sessionWarning";
+import {
+    FIFTEEN_MINUTES_INTERVAL_MILLIS,
+    FIVE_MINUTES_INTERVAL_MILLIS,
+    SAGEMAKER_METADATA_PATH,
+    SIGN_IN_BUTTON,
+    WARNING_BUTTON_REMIND_ME_IN_5_MINS,
+    WARNING_BUTTON_SAVE,
+    WARNING_BUTTON_SAVE_AND_RENEW_SESSION,
+    SagemakerCookie,
+    SagemakerResourceMetadata,
+    getExpiryTime
+} from "./constant";
+import { NotificationManager } from './notificationManager';
+import { createCapacityBlockNotificationConfig } from './capacityBlockWarning';
+import * as console from "console";
+
+
+const PARSE_SAGEMAKER_COOKIE_COMMAND = 'sagemaker.parseCookies';
+const ENABLE_AUTO_UPDATE_COMMAND = 'workbench.extensions.action.enableAutoUpdate';
+
+// Global notification manager instance
+let notificationManager: NotificationManager | null = null;
+
+
+
+function showWarningDialog() {
+    vscode.commands.executeCommand(PARSE_SAGEMAKER_COOKIE_COMMAND).then(response => {
+
+        const sagemakerCookie: SagemakerCookie = response as SagemakerCookie
+        const remainingTime: number = getExpiryTime(sagemakerCookie) - Date.now();
+
+        if(!(Object.keys(sagemakerCookie).length === 0)) {
+            if (getExpiryTime(sagemakerCookie) != null && remainingTime > FIFTEEN_MINUTES_INTERVAL_MILLIS) {
+                // This means cookie has been reset, reinitializing again
+                initialize(sagemakerCookie);
+            } else if (getExpiryTime(sagemakerCookie) != null && remainingTime > 0) {
+                // READ COOKIE again to decide to show this up
+
+                SessionWarning.sessionExpiringWarning(remainingTime, sagemakerCookie)
+                    .then((selection) => {
+                        if (selection === WARNING_BUTTON_REMIND_ME_IN_5_MINS) {
+                            // Trigger the function to show the warning again after 5 minutes.
+                            setTimeout(showWarningDialog, FIVE_MINUTES_INTERVAL_MILLIS);
+                        } else if (selection === WARNING_BUTTON_SAVE) {
+                            saveWorkspace();
+                        } else if (selection === WARNING_BUTTON_SAVE_AND_RENEW_SESSION) {
+                            saveWorkspace();
+                            // Trigger the function to make an API call to renew the session.
+                            renewSession(sagemakerCookie);
+                        }
+                    });
+
+            } else {
+                // this means expiryTime cookie is either invalid or <0
+                signInError(sagemakerCookie);
+            }
+        } else {
+            // no cookie found so assuming its running locally
+        }
+
+    });
+
+}
+
+function signInError(sagemakerCookie: SagemakerCookie) {
+    // The session has expired
+    SessionWarning.signInWarning(sagemakerCookie)
+        .then((selection) => {
+            if (selection === SIGN_IN_BUTTON) {
+                vscode.env.openExternal(vscode.Uri.parse(<string>sagemakerCookie.redirectURL));
+            }
+        });
+}
+
+function initialize(sagemakerCookie: SagemakerCookie) {
+    const currentTime = Date.now();
+    const timeToExpiry = getExpiryTime(sagemakerCookie) - currentTime;
+
+    if (timeToExpiry <= 0) {
+        signInError(sagemakerCookie);
+    } else if (timeToExpiry >= FIFTEEN_MINUTES_INTERVAL_MILLIS) {
+        const warningTime = timeToExpiry - FIFTEEN_MINUTES_INTERVAL_MILLIS;
+        setTimeout(() => {
+            showWarningDialog();
+        }, warningTime);
+    } else {
+        // If less than or equal to 15 minutes left, set a timer for the remaining time
+        const warningTime = timeToExpiry % FIVE_MINUTES_INTERVAL_MILLIS;
+        setTimeout(() => {
+            showWarningDialog();
+        }, warningTime);
+    }
+}
+
+function saveWorkspace() {
+    vscode.workspace.saveAll().then(() => {
+        // TODO: log workspace saved
+    });
+}
+function renewSession(sagemakerCookie: SagemakerCookie) {
+    // TODO: Log and trigger a Signin
+    vscode.env.openExternal(vscode.Uri.parse(<string>sagemakerCookie.redirectURL));
+    // Trigger the function to show the warning again after 5 minutes again to validate.
+    setTimeout(showWarningDialog, FIVE_MINUTES_INTERVAL_MILLIS);
+}
+
+function updateStatusItemWithMetadata(context: vscode.ExtensionContext) {
+    fs.readFile(SAGEMAKER_METADATA_PATH, 'utf-8', (err, data) => {
+        if (err) {
+            // fail silently not to block users
+        } else {
+            try {
+                const jsonData = JSON.parse(data) as SagemakerResourceMetadata;
+                const spaceName = jsonData.SpaceName;
+
+                if (spaceName != null) {
+                    let spaceNameStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
+                    spaceNameStatusBarItem.text = `Space: ${spaceName}`;
+                    spaceNameStatusBarItem.show();
+                    context.subscriptions.push(spaceNameStatusBarItem);
+                }
+            } catch (jsonError) {
+                // fail silently not to block users
+            }
+        }
+    });
+}
+
+// Render warning message regarding auto upgrade disabled
+function renderExtensionAutoUpgradeDisabledNotification() {
+    // Get current extension auto disabled config
+    const autoUpdateEnabled = vscode.workspace.getConfiguration('extensions').get('autoUpdate');
+
+    // Check if customer has choose to disable this notification
+    const extensionConfig = vscode.workspace.getConfiguration('sagemaker-extension');
+    const showNotificationEnabled = extensionConfig.get('notification.extensionAutoUpdateDisabled', true);
+
+    // Only show notification, if auto update is disabled, and customer hasn't opt-out the notification
+    if (showNotificationEnabled && autoUpdateEnabled == false) {
+        const enableAutoUpdate = 'Enable Auto Update Extensions';
+        const doNotShowAgain = 'Do not show again';
+        vscode.window.showInformationMessage(
+            'Extension auto-update is disabled. This can be changed in Code Editor settings.',
+            enableAutoUpdate,
+            doNotShowAgain,
+        ).then(response => {
+            if (response === enableAutoUpdate) {
+                vscode.commands.executeCommand(ENABLE_AUTO_UPDATE_COMMAND)
+            } else if (response == doNotShowAgain) {
+                extensionConfig.update(
+                    'notification.extensionAutoUpdateDisabled',
+                    false,
+                    vscode.ConfigurationTarget.Global
+                );
+            }
+        })
+    }
+}
+
+/**
+ * Initializes capacity block monitoring using the generic notification manager
+ */
+async function initializeCapacityBlockMonitoring(): Promise<void> {
+    if (!notificationManager) {
+        notificationManager = new NotificationManager();
+    }
+
+    const config = createCapacityBlockNotificationConfig();
+    await notificationManager.register(config);
+}
+
+export function activate(context: vscode.ExtensionContext) {
+
+    // TODO: log activation of extension
+    console.log('Activating Sagemaker Extension...');
+
+    // execute the get cookie command and save the data to cookies
+    vscode.commands.executeCommand(PARSE_SAGEMAKER_COOKIE_COMMAND).then(r => {
+
+        const sagemakerCookie: SagemakerCookie = r as SagemakerCookie
+
+        initialize(sagemakerCookie);
+        updateStatusItemWithMetadata(context);
+    });
+
+    // Initialize capacity block monitoring
+    initializeCapacityBlockMonitoring();
+
+    // render warning message regarding auto upgrade disabled
+    renderExtensionAutoUpgradeDisabledNotification();
+}
+
+/**
+ * Called when extension is deactivated
+ */
+export function deactivate(): void {
+    console.log('[Extension] Deactivating Sagemaker Extension, cleaning up notifications');
+    if (notificationManager) {
+        notificationManager.unregisterAll();
+        notificationManager = null;
+    }
+}
\ No newline at end of file
Index: code-editor-src/extensions/sagemaker-extension/src/sessionWarning.ts
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/src/sessionWarning.ts
@@ -0,0 +1,44 @@
+import * as vscode from "vscode";
+import {
+    IAM_MESSAGE,
+    isSSOMode, SagemakerCookie,
+    SIGN_IN_BUTTON,
+    SIGN_IN_HEADER,
+    SIGN_IN_MESSAGE, SIGN_IN_MESSAGE_WHEN_REDIRECT_URL_DOES_NOT_EXIST, SSO_MESSAGE,
+    WARNING_TIME_BUTTONS,
+    WARNING_TIME_HEADER
+} from "./constant";
+
+export class SessionWarning {
+
+    public static sessionExpiringWarning (warningTime: number, cookie: SagemakerCookie): Thenable<string | undefined> {
+        // convert warningTime from ms to minutes;
+        const warningTimeInMinutes: number = Math.floor(warningTime / 60000);
+        const detail: string = `Your session will expire in ${warningTimeInMinutes} minutes. If your session expires, you could lose unsaved changes \n ${isSSOMode(cookie) ? SSO_MESSAGE : IAM_MESSAGE}`
+        const sessionExpiringOptions: vscode.MessageOptions = {
+            detail: detail,
+            modal: true
+        };
+
+        // Session expiration warning...
+        if (isSSOMode(cookie)) {
+            return vscode.window.showWarningMessage(WARNING_TIME_HEADER, sessionExpiringOptions, ...WARNING_TIME_BUTTONS.SSO);
+        } else {
+            return vscode.window.showWarningMessage(WARNING_TIME_HEADER, sessionExpiringOptions, ...WARNING_TIME_BUTTONS.IAM);
+        }
+    }
+
+    public static signInWarning (cookie: SagemakerCookie): Thenable<string | undefined> {
+        const signInOptions: vscode.MessageOptions = {
+            detail: cookie.redirectURL ? SIGN_IN_MESSAGE : SIGN_IN_MESSAGE_WHEN_REDIRECT_URL_DOES_NOT_EXIST,
+            modal: true
+        };
+
+		// SignIn warning...
+        if (cookie.redirectURL) {
+            return vscode.window.showErrorMessage(SIGN_IN_HEADER, signInOptions, SIGN_IN_BUTTON);
+        } else {
+            return vscode.window.showErrorMessage(SIGN_IN_HEADER, signInOptions);
+        }
+    }
+}
\ No newline at end of file
Index: code-editor-src/extensions/sagemaker-extension/.vscodeignore
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/.vscodeignore
@@ -0,0 +1,11 @@
+.vscode/**
+.vscode-test/**
+out/test/**
+out/**
+test/**
+src/**
+tsconfig.json
+out/test/**
+out/**
+cgmanifest.json
+preview-src/**
Index: code-editor-src/extensions/sagemaker-extension/package.json
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/package.json
@@ -0,0 +1,52 @@
+{
+  "name": "sagemaker-extension",
+  "displayName": "Sagemaker Extension",
+  "description": "Sagemaker Extension",
+  "extensionKind": [
+    "workspace"
+  ],
+  "version": "1.0.0",
+  "publisher": "sagemaker",
+  "license": "MIT",
+  "engines": {
+    "vscode": "^1.70.0"
+  },
+  "main": "./out/extension",
+  "categories": [
+    "Other"
+  ],
+  "activationEvents": [
+    "*"
+  ],
+  "capabilities": {
+    "virtualWorkspaces": true,
+    "untrustedWorkspaces": {
+      "supported": true
+    }
+  },
+  "contributes": {
+    "configuration": {
+      "type": "object",
+      "title": "SageMaker Extension",
+      "properties": {
+        "sagemaker-extension.notification.extensionAutoUpdateDisabled": {
+          "type": "boolean",
+          "default": true,
+          "markdownDescription": "Show notification if extension auto update is disabled"
+        }
+      }
+    },
+    "commands": [
+    ]
+  },
+  "scripts": {
+    "compile": "gulp compile-extension:sagemaker-extension",
+    "watch": "npm run build-preview && gulp watch-extension:sagemaker-extension",
+    "vscode:prepublish": "npm run build-ext",
+    "build-ext": "node ../../node_modules/gulp/bin/gulp.js --gulpfile ../../build/gulpfile.extensions.js compile-extension:sagemaker-extension ./tsconfig.json"
+  },
+  "dependencies": {
+  },
+  "repository": {
+  }
+}
Index: code-editor-src/extensions/sagemaker-extension/README.md
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/README.md
@@ -0,0 +1,5 @@
+# Sagemaker Extension
+
+The SageMaker Extension alerts users to sign in again before their session expires. It remains active continuously and cannot be disabled.
+
+Session Management: The extension monitors the SageMaker cookie to ensure seamless session continuity. It proactively alerts users to sign in again before the session expires, enhancing the user experience by preventing unexpected session interruptions.
\ No newline at end of file
Index: code-editor-src/extensions/sagemaker-extension/tsconfig.json
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/tsconfig.json
@@ -0,0 +1,10 @@
+{
+	"extends": "../tsconfig.base.json",
+	"compilerOptions": {
+		"outDir": "./out"
+	},
+	"include": [
+		"src/**/*",
+		"../../src/vscode-dts/vscode.d.ts"
+	]
+}
Index: code-editor-src/extensions/sagemaker-extension/extension-browser.webpack.config.js
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/extension-browser.webpack.config.js
@@ -0,0 +1,13 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright Amazon.com Inc. or its affiliates. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+// @ts-check
+import { browser as withBrowserDefaults } from '../shared.webpack.config.mjs';
+
+export default withBrowserDefaults({
+	context: import.meta.dirname,
+	entry: {
+		extension: './src/extension.ts'
+	},
+});
Index: code-editor-src/extensions/sagemaker-extension/extension.webpack.config.js
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/extension.webpack.config.js
@@ -0,0 +1,16 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright Amazon.com Inc. or its affiliates. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+// @ts-check
+import withDefaults from '../shared.webpack.config.mjs';
+
+export default withDefaults({
+	context: import.meta.dirname,
+	resolve: {
+		mainFields: ['module', 'main']
+	},
+	entry: {
+		extension: './src/extension.ts',
+	}
+});
Index: code-editor-src/extensions/sagemaker-extension/src/constant.ts
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/src/constant.ts
@@ -0,0 +1,115 @@
+// Constants
+export const WARNING_TIME_HEADER = 'Session expiring soon';
+
+export const WARNING_BUTTON_REMIND_ME_IN_5_MINS = 'Remind me in 5 minutes';
+export const WARNING_BUTTON_SAVE = 'Save';
+export const WARNING_BUTTON_SAVE_AND_RENEW_SESSION = 'Save and renew session';
+export const WARNING_TIME_BUTTONS = {
+	SSO: [WARNING_BUTTON_REMIND_ME_IN_5_MINS, WARNING_BUTTON_SAVE],
+	IAM: [WARNING_BUTTON_REMIND_ME_IN_5_MINS, WARNING_BUTTON_SAVE_AND_RENEW_SESSION]
+};
+
+// Constants for signInWarning
+export const SIGN_IN_HEADER = 'Please sign in again';
+export const SIGN_IN_MESSAGE = "You were logged out of your account. Choose 'Sign In' to continue using this workplace.";
+export const SIGN_IN_MESSAGE_WHEN_REDIRECT_URL_DOES_NOT_EXIST = "You were logged out of your account. You are not able to\n" +
+	"                  perform actions in your workplace at this time. Please start a\n" +
+	"                  new session.";
+export const SIGN_IN_BUTTON = 'Sign In';
+export const SSO_MESSAGE = 'To renew the session, log out from Studio App via "File" -> "Log Out" and then "Sign out" from AWS IAM Identity Center (successor to AWS SSO) user portal. Do you want to save all changes now?';
+export const IAM_MESSAGE = 'Do you want to renew your session now?'
+export enum AUTH_MODE {
+	SSO = "Sso",
+	IAM = "Iam"
+}
+export const FIFTEEN_MINUTES_INTERVAL_MILLIS = 15 * 60 * 1000;
+export const FIVE_MINUTES_INTERVAL_MILLIS = 5 * 60 * 1000;
+
+export const SAGEMAKER_METADATA_PATH = '/opt/ml/metadata/resource-metadata.json';
+
+export class SagemakerCookie {
+	authMode: string
+	expiryTime: number
+	ssoExpiryTimestamp: number
+	studioUserProfileName: string
+	redirectURL: string
+
+	constructor(
+		authMode: string,
+		expiryTime: number,
+		ssoExpiryTimestamp: number,
+		studioUserProfileName: string,
+		redirectURL: string
+	) {
+		this.authMode = authMode;
+		this.expiryTime = expiryTime;
+		this.ssoExpiryTimestamp = ssoExpiryTimestamp
+		this.studioUserProfileName = studioUserProfileName
+		this.redirectURL = redirectURL
+	}
+};
+
+export class SagemakerResourceMetadata {
+	AppType?: string
+	DomainId?: string
+	SpaceName?: string
+	ResourceArn?: string
+	ResourceName?: string
+	AppImageVersion?: string
+};
+export function isSSOMode(cookie: SagemakerCookie) {
+	return (cookie.authMode === AUTH_MODE.SSO)
+}
+
+export function getExpiryTime(cookie: SagemakerCookie): number {
+	if (AUTH_MODE.SSO === cookie.authMode) {
+		return cookie.ssoExpiryTimestamp;
+	} else if (AUTH_MODE.IAM === cookie.authMode) {
+		return cookie.expiryTime;
+	} else {
+		return -1;
+	}
+}
+
+// Capacity Block notification constants - configurable via environment variables
+// Default values (in milliseconds)
+const DEFAULT_THIRTY_MINUTES_MILLIS = 30 * 60 * 1000;
+const DEFAULT_TEN_MINUTES_MILLIS = 10 * 60 * 1000;
+const DEFAULT_TWO_MINUTES_MILLIS = 2 * 60 * 1000;
+const DEFAULT_EC2_SHUTDOWN_BUFFER_MILLIS = 30 * 60 * 1000;
+const DEFAULT_CB_EXTENSION_TOLERANCE_MILLIS = 1 * 60 * 1000;
+
+// Scheduling constants
+const DEFAULT_MAX_TIMEOUT_MS = 2147483647; // Maximum safe setTimeout delay (~24.8 days)
+const DEFAULT_RECHECK_INTERVAL_MS = 7 * 24 * 60 * 60 * 1000; // Check every 7 days
+
+// Read from environment variables with fallback to defaults
+export const THIRTY_MINUTES_INTERVAL_MILLIS = parseInt(process.env.CB_NOTIFICATION_30MIN_MS || '') || DEFAULT_THIRTY_MINUTES_MILLIS;
+export const TEN_MINUTES_INTERVAL_MILLIS = parseInt(process.env.CB_NOTIFICATION_10MIN_MS || '') || DEFAULT_TEN_MINUTES_MILLIS;
+export const TWO_MINUTES_INTERVAL_MILLIS = parseInt(process.env.CB_NOTIFICATION_2MIN_MS || '') || DEFAULT_TWO_MINUTES_MILLIS;
+export const EC2_THIRTY_MINUTES_SHUTDOWN_MILLIS = parseInt(process.env.CB_EC2_SHUTDOWN_BUFFER_MS || '') || DEFAULT_EC2_SHUTDOWN_BUFFER_MILLIS;
+export const CB_EXTENSION_TOLERANCE_MILLIS = parseInt(process.env.CB_EXTENSION_TOLERANCE_MS || '') || DEFAULT_CB_EXTENSION_TOLERANCE_MILLIS;
+
+// Scheduling constants (exported directly, not configurable via env vars)
+export const MAX_TIMEOUT_MS = DEFAULT_MAX_TIMEOUT_MS;
+export const RECHECK_INTERVAL_MS = DEFAULT_RECHECK_INTERVAL_MS;
+
+// Feature flag for capacity block notifications (defaults to disabled)
+export const CB_NOTIFICATIONS_ENABLED = process.env.CB_NOTIFICATIONS_ENABLED === 'true' || false;
+
+export const SAGEMAKER_INTERNAL_METADATA_PATH = '/opt/.sagemakerinternal/internal-metadata.json';
+
+export const CB_WARNING_TOAST_HEADER = 'Capacity Compute Resources Expiring Soon';
+export const CB_WARNING_MODAL_HEADER = 'Critical: Compute Resources Expiring';
+export const CB_WARNING_MESSAGE_TEMPLATE = 'Your compute resources will terminate in less than {minutes} minutes. Save your work immediately to prevent data loss.';
+export const CB_SAVE_BUTTON = 'Save All';
+export const CB_DISMISS_BUTTON = 'Dismiss';
+
+export interface CapacityBlockMetadata {
+  CapacityBlockEndTime?: number;
+  CapacityBlockId?: string;
+}
+
+export interface SagemakerResourceInternalMetadata {
+  CapacityBlock?: CapacityBlockMetadata;
+}
\ No newline at end of file
Index: code-editor-src/build/gulpfile.extensions.ts
===================================================================
--- code-editor-src.orig/build/gulpfile.extensions.ts
+++ code-editor-src/build/gulpfile.extensions.ts
@@ -64,6 +64,7 @@ const compilations = [
 	'extensions/references-view/tsconfig.json',
 	'extensions/search-result/tsconfig.json',
 	'extensions/simple-browser/tsconfig.json',
+	'extensions/sagemaker-extension/tsconfig.json',
 	'extensions/tunnel-forwarding/tsconfig.json',
 	'extensions/typescript-language-features/web/tsconfig.json',
 	'extensions/typescript-language-features/tsconfig.json',
Index: code-editor-src/build/npm/dirs.ts
===================================================================
--- code-editor-src.orig/build/npm/dirs.ts
+++ code-editor-src/build/npm/dirs.ts
@@ -42,6 +42,7 @@ export const dirs = [
 	'extensions/npm',
 	'extensions/php-language-features',
 	'extensions/references-view',
+	'extensions/sagemaker-extension',
 	'extensions/search-result',
 	'extensions/simple-browser',
 	'extensions/tunnel-forwarding',
Index: code-editor-src/extensions/sagemaker-extension/src/capacityBlockWarning.ts
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/src/capacityBlockWarning.ts
@@ -0,0 +1,236 @@
+import * as vscode from 'vscode';
+import * as fs from 'fs';
+import {
+  CB_WARNING_MESSAGE_TEMPLATE,
+  CB_SAVE_BUTTON,
+  CB_WARNING_TOAST_HEADER,
+  CB_WARNING_MODAL_HEADER,
+  CapacityBlockMetadata,
+  SagemakerResourceInternalMetadata,
+  THIRTY_MINUTES_INTERVAL_MILLIS,
+  TEN_MINUTES_INTERVAL_MILLIS,
+  TWO_MINUTES_INTERVAL_MILLIS,
+  EC2_THIRTY_MINUTES_SHUTDOWN_MILLIS,
+  CB_EXTENSION_TOLERANCE_MILLIS,
+  SAGEMAKER_INTERNAL_METADATA_PATH,
+  MAX_TIMEOUT_MS,
+  RECHECK_INTERVAL_MS,
+  CB_NOTIFICATIONS_ENABLED
+} from './constant';
+import { NotificationConfig, NotificationSeverity, NotificationData } from './notificationManager';
+
+// Capacity Block specific notification data
+interface CBNotificationData extends NotificationData {
+  timeRemaining: number;
+  isModal: boolean;
+}
+
+// Test helper for injecting metadata
+let _testInternalMetadata: SagemakerResourceInternalMetadata | null | undefined = undefined;
+
+export function _testSetInternalMetadata(metadata: SagemakerResourceInternalMetadata | null): void {
+  _testInternalMetadata = metadata;
+}
+
+export function _testClearInternalMetadata(): void {
+  _testInternalMetadata = undefined;
+}
+
+function fetchInternalMetadata(): SagemakerResourceInternalMetadata | null {
+  try {
+    const data = fs.readFileSync(SAGEMAKER_INTERNAL_METADATA_PATH, 'utf-8');
+    return JSON.parse(data) as SagemakerResourceInternalMetadata;
+  } catch (error) {
+    console.error('[CB] Error reading internal metadata file:', error);
+    return null;
+  }
+}
+
+function getInternalMetadataForTesting(): SagemakerResourceInternalMetadata | null {
+  if (_testInternalMetadata !== undefined) {
+    return _testInternalMetadata;
+  }
+  return fetchInternalMetadata();
+}
+
+/**
+ * Reads capacity block metadata from internal metadata object
+ * @param internalMetadata The internal metadata object
+ * @returns CapacityBlockMetadata or null if not found
+ */
+export function readCapacityBlockMetadata(internalMetadata: SagemakerResourceInternalMetadata | null): CapacityBlockMetadata | null {
+  if (!internalMetadata) {
+    console.error('[CB] Internal metadata is null');
+    return null;
+  }
+  return internalMetadata.CapacityBlock || null;
+}
+
+/**
+ * Extracts and validates capacity block end time
+ * @param internalMetadata The internal metadata object
+ * @returns End time as Unix timestamp (ms) or null if invalid
+ */
+export function getCapacityBlockEndTime(internalMetadata: SagemakerResourceInternalMetadata | null): number | null {
+  const metadata = readCapacityBlockMetadata(internalMetadata);
+  if (!metadata?.CapacityBlockEndTime) {
+    return null;
+  }
+
+  // Convert Unix timestamp from seconds to milliseconds
+  const endTime = metadata.CapacityBlockEndTime * 1000;
+
+  if (isNaN(endTime) || endTime <= Date.now()) {
+    console.error('[CB] Invalid or past end time:', metadata.CapacityBlockEndTime);
+    return null;
+  }
+
+  return endTime;
+}
+
+/**
+ * Creates a notification config for Capacity Block warnings
+ * This integrates CB monitoring with the generic notification system
+ */
+export function createCapacityBlockNotificationConfig(): NotificationConfig<CBNotificationData> {
+  let scheduledTimeouts: NodeJS.Timeout[] = [];
+  let originalEndTime: number | null = null;
+
+  /**
+   * Schedule all CB notifications based on end time
+   */
+  function scheduleNotifications(
+    endTime: number,
+    triggerNotification: (data: CBNotificationData) => Promise<void>
+  ): void {
+    const now = Date.now();
+    const bufferTime = EC2_THIRTY_MINUTES_SHUTDOWN_MILLIS;
+
+    const intervals = [
+      { delay: endTime - now - bufferTime - THIRTY_MINUTES_INTERVAL_MILLIS, timeRemaining: THIRTY_MINUTES_INTERVAL_MILLIS, isModal: false },
+      { delay: endTime - now - bufferTime - TEN_MINUTES_INTERVAL_MILLIS, timeRemaining: TEN_MINUTES_INTERVAL_MILLIS, isModal: false },
+      { delay: endTime - now - bufferTime - TWO_MINUTES_INTERVAL_MILLIS, timeRemaining: TWO_MINUTES_INTERVAL_MILLIS, isModal: true }
+    ];
+
+    // Check if earliest notification is beyond setTimeout limit
+    const positiveDelays = intervals.map(i => i.delay).filter(d => d > 0);
+    const earliestDelay = positiveDelays.length > 0 ? Math.min(...positiveDelays) : 0;
+    
+    // If we're already within 2 minutes of shutdown, show modal immediately
+    const actualTimeRemaining = endTime - now - bufferTime;
+    if (actualTimeRemaining > 0 && actualTimeRemaining <= TWO_MINUTES_INTERVAL_MILLIS) {
+      triggerNotification({
+        timeRemaining: actualTimeRemaining,
+        isModal: true
+      });
+      return; // Don't schedule any other notifications
+    }
+    
+    if (earliestDelay > MAX_TIMEOUT_MS) {
+      const recheckTimeout = setTimeout(() => {
+        const metadata = getInternalMetadataForTesting();
+        const currentEndTime = getCapacityBlockEndTime(metadata);
+        if (!currentEndTime) {
+          console.warn('[CB] No valid end time found during recheck, stopping');
+          return;
+        }
+        originalEndTime = currentEndTime;
+        scheduleNotifications(currentEndTime, triggerNotification);
+      }, RECHECK_INTERVAL_MS);
+      
+      scheduledTimeouts.push(recheckTimeout);
+      return;
+    }
+
+    // Schedule all notifications within setTimeout range
+    intervals.forEach((interval) => {
+      if (interval.delay > 0) {
+        const timeout = setTimeout(async () => {
+          // Validate end time hasn't changed significantly
+          const metadata = getInternalMetadataForTesting();
+          const currentEndTime = getCapacityBlockEndTime(metadata);
+          
+          if (currentEndTime && originalEndTime) {
+            const timeDiff = Math.abs(currentEndTime - originalEndTime);
+            if (timeDiff > CB_EXTENSION_TOLERANCE_MILLIS) {
+              // Cancel existing and reschedule
+              scheduledTimeouts.forEach(t => clearTimeout(t));
+              scheduledTimeouts = [];
+              originalEndTime = currentEndTime;
+              scheduleNotifications(currentEndTime, triggerNotification);
+              return;
+            }
+          }
+          
+          // Show notification
+          await triggerNotification({
+            timeRemaining: interval.timeRemaining,
+            isModal: interval.isModal
+          });
+        }, interval.delay);
+
+        scheduledTimeouts.push(timeout);
+      }
+    });
+  }
+
+  return {
+    id: 'capacity-block',
+    
+    initialize: () => {
+      // Check feature flag first
+      if (!CB_NOTIFICATIONS_ENABLED) {
+        return false;
+      }
+      
+      const metadata = getInternalMetadataForTesting();
+      const endTime = getCapacityBlockEndTime(metadata);
+      
+      if (!endTime) {
+        return false;
+      }
+      
+      originalEndTime = endTime;
+      return true;
+    },
+    
+    schedule: (triggerNotification) => {
+      if (!originalEndTime) {
+        console.error('[CB] Cannot schedule without valid end time');
+        return () => {};
+      }
+      
+      scheduleNotifications(originalEndTime, triggerNotification);
+      
+      // Return cleanup function
+      return () => {
+        scheduledTimeouts.forEach(timeout => clearTimeout(timeout));
+        scheduledTimeouts = [];
+        originalEndTime = null;
+      };
+    },
+    
+    getMessage: (data) => {
+      const minutes = Math.floor(data.timeRemaining / 60000);
+      return CB_WARNING_MESSAGE_TEMPLATE.replace('{minutes}', minutes.toString());
+    },
+    
+    getHeader: (data) => {
+      return data.isModal ? CB_WARNING_MODAL_HEADER : CB_WARNING_TOAST_HEADER;
+    },
+    
+    getSeverity: () => NotificationSeverity.Warning,
+    
+    isModal: (data) => data.isModal,
+    
+    getActions: () => [
+      {
+        label: CB_SAVE_BUTTON,
+        callback: async () => {
+          console.log('[CB] User selected Save All');
+          await vscode.workspace.saveAll();
+        }
+      }
+    ]
+  };
+}
Index: code-editor-src/extensions/sagemaker-extension/src/notificationManager.ts
===================================================================
--- /dev/null
+++ code-editor-src/extensions/sagemaker-extension/src/notificationManager.ts
@@ -0,0 +1,191 @@
+import * as vscode from 'vscode';
+
+/**
+ * Notification severity level
+ */
+export enum NotificationSeverity {
+  Info = 'info',
+  Warning = 'warning',
+  Error = 'error'
+}
+
+/**
+ * Action button configuration for notifications
+ */
+export interface NotificationAction {
+  label: string;
+  callback: () => void | Promise<void>;
+}
+
+/**
+ * Base notification data that can be extended for specific use cases
+ */
+export interface NotificationData {
+  [key: string]: any;
+}
+
+/**
+ * Generic notification configuration
+ * This interface is intentionally minimal to support any notification scenario
+ */
+export interface NotificationConfig<T extends NotificationData = NotificationData> {
+  /** Unique identifier for this notification type */
+  id: string;
+  
+  /** 
+   * Initialize the notification system
+   * Returns true if initialization succeeded, false otherwise
+   */
+  initialize: () => boolean | Promise<boolean>;
+  
+  /**
+   * Schedule notification triggers
+   * Implementation is responsible for calling triggerNotification when appropriate
+   * Returns cleanup function to cancel scheduled notifications
+   */
+  schedule: (triggerNotification: (data: T) => Promise<void>) => (() => void) | Promise<() => void>;
+  
+  /**
+   * Generate notification message from data
+   */
+  getMessage: (data: T) => string;
+  
+  /**
+   * Generate notification header/title from data
+   */
+  getHeader: (data: T) => string;
+  
+  /**
+   * Get notification severity level
+   */
+  getSeverity: (data: T) => NotificationSeverity;
+  
+  /**
+   * Determine if notification should be modal
+   */
+  isModal: (data: T) => boolean;
+  
+  /**
+   * Get available actions for the notification
+   */
+  getActions: (data: T) => NotificationAction[];
+}
+
+/**
+ * Generic notification manager that can handle any notification type
+ * Completely decoupled from specific notification implementations
+ */
+export class NotificationManager {
+  private cleanupFunctions: Map<string, () => void> = new Map();
+
+  /**
+   * Register and initialize a notification provider
+   */
+  async register<T extends NotificationData>(config: NotificationConfig<T>): Promise<void> {
+    console.log(`[NotificationManager] Registering notification provider: ${config.id}`);
+    
+    const initialized = await config.initialize();
+    if (!initialized) {
+      console.log(`[NotificationManager] ${config.id}: Initialization failed or not needed`);
+      return;
+    }
+
+    // Create trigger function that will show the notification
+    const triggerNotification = async (data: T) => {
+      await this.showNotification(config, data);
+    };
+
+    // Let the config handle its own scheduling logic
+    const cleanup = await config.schedule(triggerNotification);
+    
+    if (cleanup) {
+      this.cleanupFunctions.set(config.id, cleanup);
+    }
+    
+    console.log(`[NotificationManager] ${config.id}: Successfully registered`);
+  }
+
+  /**
+   * Show a notification using VSCode's notification API
+   */
+  private async showNotification<T extends NotificationData>(
+    config: NotificationConfig<T>,
+    data: T
+  ): Promise<void> {
+    try {
+      const message = config.getMessage(data);
+      const header = config.getHeader(data);
+      const severity = config.getSeverity(data);
+      const isModal = config.isModal(data);
+      const actions = config.getActions(data);
+      
+      const fullMessage = `${header}: ${message}`;
+      const actionLabels = actions.map(a => a.label);
+      
+      let selectedAction: string | undefined;
+      const options = isModal ? { modal: true, detail: message } : { modal: false, detail: message };
+      const notifcationMessage = isModal ? header : message;
+      
+      // Show notification based on severity
+      switch (severity) {
+        case NotificationSeverity.Error:
+          selectedAction = await vscode.window.showWarningMessage(
+            `${message}`,
+            { modal: true },
+            ...actionLabels
+          );
+          break;
+        case NotificationSeverity.Warning:
+          selectedAction = await vscode.window.showWarningMessage(
+            notifcationMessage,
+            options as any,
+            ...actionLabels
+          );
+          break;
+        case NotificationSeverity.Info:
+        default:
+          selectedAction = await vscode.window.showInformationMessage(
+            fullMessage,
+            options as any,
+            ...actionLabels
+          );
+          break;
+      }
+
+      if (selectedAction) {
+        const action = actions.find(a => a.label === selectedAction);
+        if (action) {
+          console.log(`[NotificationManager] ${config.id}: User selected '${selectedAction}'`);
+          await action.callback();
+        }
+      }
+    } catch (error) {
+      console.error(`[NotificationManager] ${config.id}: Failed to show notification:`, error);
+    }
+  }
+
+  /**
+   * Unregister a specific notification provider
+   */
+  unregister(id: string): void {
+    console.log(`[NotificationManager] Unregistering notification provider: ${id}`);
+    
+    const cleanup = this.cleanupFunctions.get(id);
+    if (cleanup) {
+      cleanup();
+      this.cleanupFunctions.delete(id);
+    }
+  }
+
+  /**
+   * Unregister all notification providers
+   */
+  unregisterAll(): void {
+    console.log('[NotificationManager] Unregistering all notification providers');
+    for (const [id, cleanup] of this.cleanupFunctions.entries()) {
+      console.log(`[NotificationManager] Cleaning up: ${id}`);
+      cleanup();
+    }
+    this.cleanupFunctions.clear();
+  }
+}
